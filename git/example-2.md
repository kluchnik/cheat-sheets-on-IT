# Пример 2

За основу была взята модель GitLab Flow (http://docs.gitlab.com/ee/workflow/gitlab_flow.html).  

Все репозитории проекта имеют две основные ветки: master и production, а также feature-ветки.  

* Ветка **master** - основная ветка, в которой продукт содержит последние реализованные фичи. Продукт из этой ветки должен собираться, проходить все автоматические тесты и быть в рабочем состоянии. Система сборки собирает testing билды из этой ветки.  
* Ветка **production** - содержит только релизы с соответствующими тэгами. В этой ветке никогда не ведется разработка, только слияния состояний из ветки master, когда они признаются готовыми к релизу. Исключения составляют супер-срочные хотфиксы (разработка которых ведется в собственных feature-ветках). Готовые хотфиксы для production вносятся одновременно и в master (конечно если они актуальны для master). Система сборки собирает stable релизы из этой ветки.  
* Ветки **feature-branch** предназначены для разработки нового функционала или багфиксов. Ветки создаются в соответствии с задачами Redmine. Не может быть одной ветки на несколько задач, но может быть несколько веток на одну задачу. В своем названии ветка должна обязательно содержать номер задачи Redmine и краткое описание. Например 13578-kali-menu-translate. По завершении работы над веткой у себя, необходимо влить в неё последние изменения из master и еще раз проверить. Если все в порядке, ветка пушится в GitLab, где она будет собрана gitlab-ci. Если ветка признается рабочей, создается merge request в master.  

Проект моможет состоять из нескольких компонентов, но релизится общей сборкой. При выходе очередного релиза соответствующее состояние master-веток во всех репозиториях сливается в production и создаётся тег релиза. Если изменений с прошлого релиза в репозитории не было, на тот же коммит ставится еще один тег.  

## Пример работы  
Допустим разработчику необходимо реализовать фичу из задачи N в Redmine.  

1. От текущего состояния ветки master отделяется новая ветка N-short-feature-description.  
```
$ git checkout master
$ git checkout -b N-short-feature-description
```
2. В этой ветке ведётся разработка в обычном режиме, с коммитами по необходимости. Изменять коммиты (уплотнять, разбивать, переупорядочивать и т.п.) можно только локально у себя до пуша в GitLab.  
3. Когда разработка закончена, разработчик должен накатить в ветку последние изменения из ветки master и проверить, что ничего не сломалось (как минимум должны проходить все автоматические тесты)  
```
$ git fetch origin master
$ git merge master
```
4. После проверки нужно сделать push ветки в GitLab. После того как ветка отправлена в GitLab, изменять коммиты в ней запрещено.  
```
$ git push -u origin N-short-feature-description
```
5. После успешной сборки и тестирования, в GitLab делается merge request в ветку master.  
6. Когда merge request будет подтвержден, feature ветка будет удалена в GitLab, и останется удалить её локально.  
```
$ git remote prune origin
```

## Правила оформления сообщений к коммитам  

Поставьте себе хук из репозитория git-setup. Хук будет автоматически подставлять refs #N из названия ветки, и дополнительно проверять что коммит идет в фичеветку, а не в master или dev.  

Следуйте общепринятым правилам (https://chris.beams.io/posts/git-commit/):  
* Комментарий состоит из заголовка длиной не больше 50 символов и тела не больше 72 символов  
* Заголовок от тела комментария отделяется пустой строкой  
* Точка в конце заголовка не ставится  
* Заголовок начинается с заглавной буквы  
* Если изменение по сути небольшое, можно обойтись только заголовком  
* Используйте тело комментария для объяснения что сделано и почему. Не надо писать как именно, это видно по изменению кода  
* Старайтесь делать коммиты атомарными. Т.е. делайте отдельные коммиты на каждое логическое изменение кода  

Эти правила хорошо вписываются в 4 уровня подробности при выводе лога:  
1. Показать только заголовки комментариев  
```
$ git log --oneline
```
2. Показать только комментарии к коммитам  
```
$ git log
```
3. Показать комментарии к коммитам и статистику изменения файлов  
```
$ git log --stat
```
4. Показать комментарии и изменения файлов  
```
$ git log -p
```

Дополнительные правила:  
* Сообщения к коммитам, как и комментарии в исходном коде, пишутся на английском языке.  
* Ставьте ссылку на номер задачи в Redmine (https://www.redmine.org/projects/redmine/wiki/RedmineSettings#Referencing-issues-in-commit-messages) в теле комментария отдельной последней строкой. Например:  
```
Implement basic HTTP authentication

refs #31337
```
* Смысл сообщений в коммитах такой же, как у комментариев в исходном коде (https://moscowpython.ru/meetup/16/source-comments/).  

**Примеры плохих комментариев**:  
```
commit 75228ee596f01f5c8f89be840ed564c9495939f3
Author: John Smith <j.smith@example.com>
Date:   Tue Jun 28 12:59:59 2011 +0400

closes #1593
```
* Не понятно что и для чего сделано, только отсылка на трекер.

**Примеры хороших комментариев:**  
```
commit fca4a88c7e99c0b582b4de6e8b35e22fb3d4e6d9
Author: John Smith <j.smith@example.com>
Date:   Mon Jan 18 12:11:40 2016 +0300

Small refactoring

Remove unnecessary curly braces around variables
Give some variables more proper names
refs #10841
```

## Работа с оригинальными ветками при внесении изменений в open-source продукты  

* В наш общий репозиторий мы не тащим оригинальные ветки из open-source  
* При появлении изменений в open-source репозитории создается задача в Redmine на внесение этих изменений в наш репозиторий. Затем по стандартному процессу создается ветка задачи, туда вливаются изменения, проверяется работоспособность в dev, далее изменения попадают в master и production.
Следует максимально избегать практики непосредственного патчинга open-source (по крайней мере в проекте Сканер-ВС), и использовать её только для предложения наших изменений в upstream оригинального репозитория  
* Когда наши изменения приняты в оригинальном репозитории, дальнейшая поддержка теряет смысл и наша копия должна быть удалена  
